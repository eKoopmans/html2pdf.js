<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: worker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: worker.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { jsPDF } from 'jspdf';
import * as html2canvas from 'html2canvas';
import { objType, createElement, cloneNode, toPx } from './utils.js';
import es6promise from 'es6-promise';
var Promise = es6promise.Promise;


/**
 * Converts/casts promises into Workers
 * @param {Promise} promise 
 * @param {*} [inherit]  prototype to inherit from for the new worker, defaults to Worker.prototype 
 * @returns {worker}
 */
function convert(promise, inherit) {
  // Uses prototypal inheritance to receive changes made to ancestors' properties.
  promise.__proto__ = inherit || Worker.prototype;
  return promise;
}

/**
 * @typedef {Object} workerProp
 * @property {HTMLElement} src - The source HTML element.
 * @property {HTMLElement} container - The container element.
 * @property {HTMLElement} overlay - The overlay element.
 * @property {HTMLCanvasElement} canvas - The canvas element.
 * @property {HTMLImageElement} img - The image element.
 * @property {jsPDF} pdf - The jsPDF object.
 * @property {Array} pageSize - The page size.
 */

/**
 * @typedef {Object} workerProgress
 * @property {Number} val - The current progress value.
 * @property {String} state - The current progress state.
 * @property {Number} n - The current progress step.
 * @property {Array} stack - The current progress stack.
 * @property {Number} ratio - The current progress ratio.
 */

/**
 * @typedef {Object} workerOpt
 * @property {String} filename - The filename of the PDF.
 * @property {Array} margin - The page margins.
 * @property {Object} image - The image options.
 * @property {String} image.type - The image type.
 * @property {Number} image.quality - The image quality.
 * @property {Boolean} enableLinks - Whether to enable links.
 * @property {Object} html2canvas - The html2canvas options.
 * @property {Object} jsPDF - The jsPDF options.
 */


/* ----- CONSTRUCTOR ----- */
/**
 * @constructs worker
 */
var Worker = function Worker(opt) {
  // Create the root parent for the proto chain, and the starting Worker.
  var root = Object.assign(convert(Promise.resolve()),
                           JSON.parse(JSON.stringify(Worker.template)));
  var self = convert(Promise.resolve(), root);

  // Set progress, optional settings, and return.
  this.progress = {
    val: 1,
    state: Worker,
    n: 1,
    stack: [Worker],
    ratio: 1 / Worker
  }
  self = self.set(opt);
  return self;
};

// Boilerplate for subclassing Promise.
Worker.prototype = Object.create(Promise.prototype);
Worker.prototype.constructor = Worker;


/**
* @type {object}
* @property {workerProp} prop
* @property {workerProgress} progress
* @property {workerOpt} opt
*/
Worker.template = {
 prop: {
   src: null,
   container: null,
   overlay: null,
   canvas: null,
   img: null,
   pdf: null,
   pageSize: null
 },
 progress: {
   val: 0,
   state: null,
   n: 0,
   stack: [],
   ratio: NaN
 },
 opt: {
   filename: 'file.pdf',
   margin: [0,0,0,0],
   image: { type: 'jpeg', quality: 0.95 },
   enableLinks: true,
   html2canvas: {},
   jsPDF: {}
 }
};

/* ----- FROM / TO ----- */


/**
 * Sets the source (HTML string or element) for the PDF
 * Adds a promise to the promise chain, which modifies calls this.set() to update src, canvas, or img.
 * @param {*} src 
 * @param {"string"|"element"|"canvas"|"img"} [type] 
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.from = function from(src, type) {
  function getType(src) {
    switch (objType(src)) {
      case 'string':  return 'string';
      case 'element': return src.nodeName.toLowerCase === 'canvas' ? 'canvas' : 'element';
      default:        return 'unknown';
    }
  }

  return this.then(function from_main() {
    type = type || getType(src);
    switch (type) {
      case 'string':  return this.set({ src: createElement('div', {innerHTML: src}) });
      case 'element': return this.set({ src: src });
      case 'canvas':  return this.set({ canvas: src });
      case 'img':     return this.set({ img: src });
      default:        return this.error('Unknown source type.');
    }
  });
};


/**
 * Wrapper for toContainer, toCanvas, toImg, and toPdf.
 * 
 * How the 'to' system works:
 * To create the pdf, we create a container element, convert it to a canvas, convert the canvas to an image, and then convert the image to a pdf.
 * Therefore, .toContainer, .toCanvas, .toImg, and .toPdf must all be called, in that order.
 * To create a user-friendly API, we do not require the user to call all four functions.
 * Instead, there is a "prereq" system:
 * Each function has a list of prereq functions, which are passed into the .thenList() function, and THEN the main function is passed into .then().
 * Each prereq function checks to see if its condition is met, and if not, it returns a promise to run the necessary function, which gets put on the chain by .thenList
 * 
 * @param {"container"|"canvas"|"img"|"pdf"} target
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.to = function to(target) {
  // Route the 'to' request to the appropriate method.
  switch (target) {
    case 'container':
      return this.toContainer();
    case 'canvas':
      return this.toCanvas();
    case 'img':
      return this.toImg();
    case 'pdf':
      return this.toPdf();
    default:
      return this.error('Invalid target.');
  }
};

/**
 * Creates the container element that the pdf will be generated from.  this.prop.src must be set.
 * The container element is like this, and it gets appended to the document body:
 * &lt;div class="html2pdf__overlay">
 *  &lt;div class="html2pdf__container">&lt;/div>
 * &lt;/div>
 * The overlay and container divs are assigned to this.prop.overlay and this.prop.container, respectively.
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.toContainer = function toContainer() {
  // Set up function prerequisites.
  var prereqs = [
    function checkSrc() { return this.prop.src || this.error('Cannot duplicate - no source HTML.'); },
    function checkPageSize() { return this.prop.pageSize || this.setPageSize(); }
  ];

  return this.thenList(prereqs).then(function toContainer_main() {
    // Define the CSS styles for the container and its overlay parent.
    var overlayCSS = {
      position: 'fixed', overflow: 'hidden', zIndex: 1000,
      left: 0, right: 0, bottom: 0, top: 0,
      backgroundColor: 'rgba(0,0,0,0.8)'
    };
    var containerCSS = {
      position: 'absolute', width: this.prop.pageSize.inner.width + this.prop.pageSize.unit,
      left: 0, right: 0, top: 0, height: 'auto', margin: 'auto',
      backgroundColor: 'white'
    };

    // Set the overlay to hidden (could be changed in the future to provide a print preview).
    overlayCSS.opacity = 0;

    // Create and attach the elements.
    var source = cloneNode(this.prop.src, this.opt.html2canvas.javascriptEnabled);
    this.prop.overlay = createElement('div',   { className: 'html2pdf__overlay', style: overlayCSS });
    this.prop.container = createElement('div', { className: 'html2pdf__container', style: containerCSS });
    this.prop.container.appendChild(source);
    this.prop.overlay.appendChild(this.prop.container);
    document.body.appendChild(this.prop.overlay);
  });
};


/**
 * Creates a canvas element from the container element, by calling html2canvas.
 * removes the overlay div from the body when done.
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.toCanvas = function toCanvas() {
  // Set up function prerequisites.
  var prereqs = [
    function checkContainer() { return document.body.contains(this.prop.container) ||
                                this.toContainer(); }
  ];

  // Fulfill prereqs then create the canvas.
  return this.thenList(prereqs).then(function toCanvas_main() {
    // Handle old-fashioned 'onrendered' argument.
    var options = Object.assign({}, this.opt.html2canvas);
    delete options.onrendered;

    return html2canvas(this.prop.container, options);
  }).then(function toCanvas_post(canvas) {
    // Handle old-fashioned 'onrendered' argument.
    var onRendered = this.opt.html2canvas.onrendered || function () {};
    onRendered(canvas);

    this.prop.canvas = canvas;
    document.body.removeChild(this.prop.overlay);
  });
};


/**
 * Converts the canvas to an image by setting the data URL as the src of a new image element.
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.toImg = function toImg() {
  // Set up function prerequisites.
  var prereqs = [
    function checkCanvas() { return this.prop.canvas || this.toCanvas(); }
  ];

  // Fulfill prereqs then create the image.
  return this.thenList(prereqs).then(function toImg_main() {
    var imgData = this.prop.canvas.toDataURL('image/' + this.opt.image.type, this.opt.image.quality);
    this.prop.img = document.createElement('img');
    this.prop.img.src = imgData;
  });
};


/**
 * Creates the pdf by setting this.prop.pdf to a new jsPDF object, splitting the canvas into pages, and adding each page to the pdf using the jspdf addImage function.
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.toPdf = function toPdf() {
  // Set up function prerequisites.
  var prereqs = [
    function checkCanvas() { return this.prop.canvas || this.toCanvas(); }
  ];

  // Fulfill prereqs then create the image.
  return this.thenList(prereqs).then(function toPdf_main() {
    // Create local copies of frequently used properties.
    var canvas = this.prop.canvas;
    var opt = this.opt;

    // Calculate the number of pages.
    var pxFullHeight = canvas.height;
    var pxPageHeight = Math.floor(canvas.width * this.prop.pageSize.inner.ratio);
    var nPages = Math.ceil(pxFullHeight / pxPageHeight);

    // Define pageHeight separately so it can be trimmed on the final page.
    var pageHeight = this.prop.pageSize.inner.height;

    // Create a one-page canvas to split up the full image.
    var pageCanvas = document.createElement('canvas');
    var pageCtx = pageCanvas.getContext('2d');
    pageCanvas.width = canvas.width;
    pageCanvas.height = pxPageHeight;

    // Initialize the PDF.
    this.prop.pdf = this.prop.pdf || new jsPDF(opt.jsPDF);

    for (var page=0; page&lt;nPages; page++) {
      // Trim the final page to reduce file size.
      if (page === nPages-1 &amp;&amp; pxFullHeight % pxPageHeight !== 0) {
        pageCanvas.height = pxFullHeight % pxPageHeight;
        pageHeight = pageCanvas.height * this.prop.pageSize.inner.width / pageCanvas.width;
      }

      // Display the page.
      var w = pageCanvas.width;
      var h = pageCanvas.height;
      pageCtx.fillStyle = 'white';
      pageCtx.fillRect(0, 0, w, h);
      pageCtx.drawImage(canvas, 0, page*pxPageHeight, w, h, 0, 0, w, h);

      // Add the page to the PDF.
      if (page)  this.prop.pdf.addPage();
      var imgData = pageCanvas.toDataURL('image/' + opt.image.type, opt.image.quality);
      this.prop.pdf.addImage(imgData, opt.image.type, opt.margin[1], opt.margin[0],
                        this.prop.pageSize.inner.width, pageHeight);
    }
  });
};


/* ----- OUTPUT / SAVE ----- */

/**
 * Wrapper for outputPdf and outputImg.
 * @param {"arraybuffer"|"blob"|"bloburi"|"bloburl"|"datauristring"|"dataurlstring"|"dataurlnewwindow"|"datauri"|"dataurl"|"img"} type
 * @param {*} options if pdf - options for jsPDF.output, if img, unused.
 * @param {"img"|"image"|"pdf"} src 
 * @returns {worker} returns itself for chaining.  
 */
Worker.prototype.output = function output(type, options, src) {
  // Redirect requests to the correct function (outputPdf / outputImg).
  src = src || 'pdf';
  if (src.toLowerCase() === 'img' || src.toLowerCase() === 'image') {
    return this.outputImg(type, options);
  } else {
    return this.outputPdf(type, options);
  }
};


/**
 * Make sure the pdf is available, then call the jsPDF output function.
 * @param {"arraybuffer"|"blob"|"bloburi"|"bloburl"|"datauristring"|"dataurlstring"|"dataurlnewwindow"|"datauri"|"dataurl"} type
 * @param {*} options options for jsPDF.output
 * @returns {worker} returns itself for chaining.  
 */
Worker.prototype.outputPdf = function outputPdf(type, options) {
  // Set up function prerequisites.
  var prereqs = [
    function checkPdf() { return this.prop.pdf || this.toPdf(); }
  ];

  // Fulfill prereqs then perform the appropriate output.
  return this.thenList(prereqs).then(function outputPdf_main() {
    /* Currently implemented output types:
     *    https://rawgit.com/MrRio/jsPDF/master/docs/jspdf.js.html#line992
     *  save(options), arraybuffer, blob, bloburi/bloburl,
     *  datauristring/dataurlstring, dataurlnewwindow, datauri/dataurl
     */
    return this.prop.pdf.output(type, options);
  });
};


/**
 * Add a function to the promise chain that will return the image data
 * @param {"datauristring"|"dataurlstring"|"datauri"|"dataurl"|"img"} type desired output type
 * @param {*} options unused, but included for consistency with outputPdf
 * @returns {worker} returns itself for chaining. 
 */
Worker.prototype.outputImg = function outputImg(type, options) {
  // Set up function prerequisites.
  var prereqs = [
    function checkImg() { return this.prop.img || this.toImg(); }
  ];

  // Fulfill prereqs then perform the appropriate output.
  return this.thenList(prereqs).then(function outputImg_main() {
    switch (type) {
      case undefined:
      case 'img':
        return this.prop.img;
      case 'datauristring':
      case 'dataurlstring':
        return this.prop.img.src;
      case 'datauri':
      case 'dataurl':
        document.location.href = this.prop.img.src;
        return this.prop.img.src;
      default:
        throw 'Image output type "' + type + '" is not supported.';
    }
  });
};


/**
 * Adds a promise to the chain which will call jsPDF.save() to save the PDF to the user's computer.
 * @param {string} [filename] optional filename, if not included the jsPDF default will be used
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.save = function save(filename) {
  // Set up function prerequisites.
  var prereqs = [
    function checkPdf() { return this.prop.pdf || this.toPdf(); }
  ];

  // Fulfill prereqs, update the filename (if provided), and save the PDF.
  return this.thenList(prereqs).set(
    filename ? { filename: filename } : null
  ).then(function save_main() {
    this.prop.pdf.save(this.opt.filename);
  });
};

/* ----- SET / GET ----- */

/**
 * Queue up functions on the promise chain that will set properties of the worker.
 * @param {object} opt name-value pairs of the new property values to set
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.set = function set(opt) {
  // TODO: Implement ordered pairs?

  // Silently ignore invalid or empty input.
  if (objType(opt) !== 'object') {
    return this;
  }

  // Build an array of setter functions to queue.
  var fns = Object.keys(opt || {}).map(function (key) {
    switch (key) {
      case 'margin':
        return this.setMargin.bind(this, opt.margin);
      case 'jsPDF':
        return function set_jsPDF() { this.opt.jsPDF = opt.jsPDF; return this.setPageSize(); }
      case 'pageSize':
        return this.setPageSize.bind(this, opt.pageSize);
      default:
        if (key in Worker.template.prop) {
          // Set pre-defined properties in prop.
          return function set_prop() { this.prop[key] = opt[key]; }
        } else {
          // Set any other properties in opt.
          return function set_opt() { this.opt[key] = opt[key] };
        }
    }
  }, this);

  // Set properties within the promise chain.
  return this.then(function set_main() {
    return this.thenList(fns);
  });
};


/**
 * Add a function to the promise chain that gets a value of one one of the worker's options or properties - you can also provide a callback to receive the value
 * @param {string} key property to get
 * @param {Function} [cbk] If included, called with the value and this method returns the return value of cbk.
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.get = function get(key, cbk) {
  return this.then(function get_main() {
    // Fetch the requested property, either as a predefined prop or in opt.
    var val = (key in Worker.template.prop) ? this.prop[key] : this.opt[key];
    return cbk ? cbk(val) : val;
  });
};


/**
 * Adds a set margin function to the promise chain, which modifies this.opt.margin.
 * Also adds this.setPageSize to the promise chain immediately after.
 * @param {number|Array} margin number sets all four margins.  array length 2 sets [vertical, horizontal].  array length 4 sets all margins.  Otherwise, calls this.error().
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.setMargin = function setMargin(margin) {
  return this.then(function setMargin_main() {
    // Parse the margin property: [top, left, bottom, right].
    switch (objType(margin)) {
      case 'number':
        margin = [margin, margin, margin, margin];
      case 'array':
        if (margin.length === 2) {
          margin = [margin[0], margin[1], margin[0], margin[1]];
        }
        if (margin.length === 4) {
          break;
        }
      default:
        return this.error('Invalid margin array.');
    }

    // Set the margin property, then update pageSize.
    this.opt.margin = margin;
  }).then(this.setPageSize);
}


/**
 * Adds a set page size function to the promise chain, which modifies this.prop.pageSize.
 * @param {object} [pageSize] Optional, finds the page size based on jsPDF settings if not provided.
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.setPageSize = function setPageSize(pageSize) {
  return this.then(function setPageSize_main() {
    // Retrieve page-size based on jsPDF settings, if not explicitly provided.
    pageSize = pageSize || jsPDF.getPageSize(this.opt.jsPDF);

    // Add 'inner' field if not present.
    if (!pageSize.hasOwnProperty('inner')) {
      pageSize.inner = {
        width:  pageSize.width - this.opt.margin[1] - this.opt.margin[3],
        height: pageSize.height - this.opt.margin[0] - this.opt.margin[2]
      };
      pageSize.inner.px = {
        width:  toPx(pageSize.inner.width, pageSize.k),
        height: toPx(pageSize.inner.height, pageSize.k)
      };
      pageSize.inner.ratio = pageSize.inner.height / pageSize.inner.width;
    }

    // Attach pageSize to this.
    this.prop.pageSize = pageSize;
  });
}


/**
 * Update the progress properties of the worker - I believe the goal here is to take the entire promise chain, and after each one resolves, we update the progress properties with how far along the chain we are.
 * @param {number} val ??
 * @param {*} state ??
 * @param {number} n current progress step
 * @param {Array} stack stack of objects that do something ??
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.updateProgress = function updateProgress(val, state, n, stack) {
  if (val) this.progress.val += val;
  if (state) this.progress.state = state;
  if (n) this.progress.n += n;
  if (stack) this.progress.stack = this.progress.stack.concat(stack);
  this.progress.ratio = this.progress.val / this.progress.state;  // This doesn't work right now but it's okay - it just gets set to NaN and isn't used.

  // Return this for command chaining.
  return this
};

/* ----- PROMISE MAPPING ----- */


/**
 * .then but with extras!  .updateProgress gets called every time, and thenCore gets called instead of the native Promise .then
 * @param {Function} onFulfilled  resolve
 * @param {Function} onRejected   reject
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.then = function then(onFulfilled, onRejected) {
  // Wrap `this` for encapsulation.
  var self = this;

  return this.thenCore(onFulfilled, onRejected, function then_main(onFulfilled, onRejected) {
    // Update progress while queuing, calling, and resolving `then`.
    self.updateProgress(null, null, 1, [onFulfilled]);
    return Promise.prototype.then.call(this, function then_pre(val) {
      self.updateProgress(null, onFulfilled);
      return val;
    }).then(onFulfilled, onRejected).then(function then_post(val) {
      self.updateProgress(1);
      return val;
    });
  });
};


/**
 * the core of the .then method - this is what gets called instead of the native Promise .then
 * @param {Function} onFulfilled 
 * @param {Function} onRejected 
 * @param {Function} [thenBase]  optional replacement for Promise.prototype.then
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.thenCore = function thenCore(onFulfilled, onRejected, thenBase) {
  // Handle optional thenBase parameter.
  thenBase = thenBase || Promise.prototype.then;

  // Wrap `this` for encapsulation and bind it to the promise handlers.
  var self = this;
  if (onFulfilled)  { onFulfilled = onFulfilled.bind(self); }
  if (onRejected)   { onRejected = onRejected.bind(self); }

  // Cast self into a Promise to avoid polyfills recursively defining `then`.
  var isNative = Promise.toString().indexOf('[native code]') !== -1 &amp;&amp; Promise.name === 'Promise';
  var selfPromise = isNative ? self : convert(Object.assign({}, self), Promise.prototype);

  // Return the promise, after casting it into a Worker and preserving props.
  var returnVal = thenBase.call(selfPromise, onFulfilled, onRejected);
  return convert(returnVal, self.__proto__);
};


/**
 * Call `then` and return a standard promise (exits the Worker chain).
 * @param {Function} onFulfilled  'resolve' in a normal promise.
 * @param {Function} onRejected   'reject' in a normal promise.
 * @returns {Promise}
 */
Worker.prototype.thenExternal = function thenExternal(onFulfilled, onRejected) {
  return Promise.prototype.then.call(this, onFulfilled, onRejected);
};


/**
 * Queue a series of promise 'factories' into the promise chain.
 * @param {Function[]} fns array of functions that may return promises, to add to the promise chain.
 * @returns {worker} returns itself for chaining.
 */
Worker.prototype.thenList = function thenList(fns) {
  var self = this;
  fns.forEach(function thenList_forEach(fn) {
    self = self.thenCore(fn);  // Don't need to pass onRejected because errors will be caught by any .catch() in the chain.
  });
  return self;
};


/**
 * Bind `this` to the promise handler, call `catch`, and return a Worker.
 * @param {Function} onRejected 
 * @returns {worker} 
 */
Worker.prototype['catch'] = function (onRejected) {
  if (onRejected)   { onRejected = onRejected.bind(this); }
  var returnVal = Promise.prototype['catch'].call(this, onRejected);
  return convert(returnVal, this);
};


/**
 * Call `catch` and return a standard promise (exits the Worker chain).
 * @param {Function} onRejected 
 * @returns {Promise}
 */
Worker.prototype.catchExternal = function catchExternal(onRejected) {
  return Promise.prototype['catch'].call(this, onRejected);
};


/**
 * Throw the error in the Promise chain.
 * @param {string} msg 
 * @returns {worker} returns itself for chaining (although in this case 'chaining' just means it will skip ahead to any .catch once it throws the error)
 */
Worker.prototype.error = function error(msg) {
  return this.then(function error_main() {
    throw new Error(msg);
  });
};


/* ----- ALIASES ----- */

Worker.prototype.using = Worker.prototype.set;
Worker.prototype.saveAs = Worker.prototype.save;
Worker.prototype.export = Worker.prototype.output;
Worker.prototype.run = Worker.prototype.then;


/* ----- FINISHING ----- */

// Expose the Worker class.
export default Worker;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="worker.html">worker</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cloneNode">cloneNode</a></li><li><a href="global.html#convert">convert</a></li><li><a href="global.html#createElement">createElement</a></li><li><a href="global.html#html2pdf">html2pdf</a></li><li><a href="global.html#objType">objType</a></li><li><a href="global.html#toPx">toPx</a></li><li><a href="global.html#unitConvert">unitConvert</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Mon Feb 20 2023 11:08:11 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
